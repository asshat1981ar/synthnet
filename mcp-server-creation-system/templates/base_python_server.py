#!/usr/bin/env python3
"""
Base MCP Server Template - Python Implementation
Generated by MCP Server Creation System

This template provides a foundation for creating MCP servers with:
- Tool execution capabilities
- Resource access functionality
- Dynamic prompt templates
- Comprehensive error handling
- Logging and monitoring
- Security best practices
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Union
from datetime import datetime
import json

from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializeResult
import mcp.server.stdio
import mcp.types as types

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class {ServerClassName}:
    """
    {ServerDescription}
    
    This server provides:
    - {ToolsDescription}
    - {ResourcesDescription} 
    - {PromptsDescription}
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the MCP server with optional configuration."""
        self.config = config or {{}}
        self.server = Server("{server_name}")
        self.setup_handlers()
        logger.info(f"Initialized {{self.__class__.__name__}} server")
    
    def setup_handlers(self):
        """Setup all MCP handlers for tools, resources, and prompts."""
        
        # List available tools
        @self.server.list_tools()
        async def list_tools() -> List[types.Tool]:
            """List all available tools provided by this server."""
            return [
                {tools_list}
            ]
        
        # Handle tool execution
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Optional[Dict[str, Any]]) -> List[types.TextContent]:
            """Execute a tool with the given arguments."""
            try:
                logger.info(f"Executing tool: {{name}} with args: {{arguments}}")
                
                {tool_handlers}
                
                else:
                    raise ValueError(f"Unknown tool: {{name}}")
                    
            except Exception as e:
                logger.error(f"Error executing tool {{name}}: {{str(e)}}")
                return [types.TextContent(
                    type="text", 
                    text=f"Error executing {{name}}: {{str(e)}}"
                )]
        
        # List available resources
        @self.server.list_resources()
        async def list_resources() -> List[types.Resource]:
            """List all available resources provided by this server."""
            return [
                {resources_list}
            ]
        
        # Handle resource reading
        @self.server.read_resource()
        async def read_resource(uri: str) -> str:
            """Read content from a resource URI."""
            try:
                logger.info(f"Reading resource: {{uri}}")
                
                {resource_handlers}
                
                else:
                    raise ValueError(f"Unknown resource URI: {{uri}}")
                    
            except Exception as e:
                logger.error(f"Error reading resource {{uri}}: {{str(e)}}")
                raise
        
        # List available prompts
        @self.server.list_prompts()
        async def list_prompts() -> List[types.Prompt]:
            """List all available prompts provided by this server."""
            return [
                {prompts_list}
            ]
        
        # Handle prompt retrieval
        @self.server.get_prompt()
        async def get_prompt(name: str, arguments: Optional[Dict[str, str]]) -> types.GetPromptResult:
            """Get a prompt template with arguments."""
            try:
                logger.info(f"Getting prompt: {{name}} with args: {{arguments}}")
                
                {prompt_handlers}
                
                else:
                    raise ValueError(f"Unknown prompt: {{name}}")
                    
            except Exception as e:
                logger.error(f"Error getting prompt {{name}}: {{str(e)}}")
                raise
    
    async def {example_tool_method}(self, **kwargs) -> List[types.TextContent]:
        """
        Example tool implementation.
        Replace with your specific tool logic.
        """
        # Implement your tool logic here
        result = "Example tool result"
        
        return [types.TextContent(
            type="text",
            text=result
        )]
    
    async def {example_resource_method}(self, uri: str) -> str:
        """
        Example resource implementation.
        Replace with your specific resource logic.
        """
        # Implement your resource logic here
        return f"Resource content for {{uri}}"
    
    async def {example_prompt_method}(self, arguments: Dict[str, str]) -> types.GetPromptResult:
        """
        Example prompt implementation.
        Replace with your specific prompt logic.
        """
        # Implement your prompt logic here
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(
                    type="text",
                    text="Example prompt content"
                )
            )
        ]
        
        return types.GetPromptResult(messages=messages)
    
    def validate_config(self) -> bool:
        """Validate server configuration."""
        required_keys = {required_config_keys}
        missing_keys = [key for key in required_keys if key not in self.config]
        
        if missing_keys:
            logger.error(f"Missing required configuration keys: {{missing_keys}}")
            return False
        
        return True
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check and return status."""
        return {{
            "status": "healthy",
            "timestamp": datetime.utcnow().isoformat(),
            "version": "1.0.0",
            "config_valid": self.validate_config()
        }}
    
    async def run(self):
        """Run the MCP server."""
        if not self.validate_config():
            logger.error("Invalid configuration, server cannot start")
            return
        
        logger.info("Starting MCP server...")
        
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream, 
                write_stream, 
                InitializeResult(
                    protocolVersion="2024-11-05",
                    capabilities=types.ServerCapabilities(
                        tools={{}} if {has_tools} else None,
                        resources={{}} if {has_resources} else None,
                        prompts={{}} if {has_prompts} else None,
                        logging={{}}
                    ),
                    serverInfo=types.Implementation(
                        name="{server_name}",
                        version="1.0.0"
                    )
                )
            )

async def main():
    """Main entry point for the server."""
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(description="{ServerDescription}")
    parser.add_argument("--config", type=str, help="Path to configuration file")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    config = {{}}
    if args.config:
        try:
            with open(args.config, 'r') as f:
                config = json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config file: {{e}}")
            sys.exit(1)
    
    server = {ServerClassName}(config)
    
    try:
        await server.run()
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
    except Exception as e:
        logger.error(f"Server error: {{e}}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())