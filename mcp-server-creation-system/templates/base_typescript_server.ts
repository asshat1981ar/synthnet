#!/usr/bin/env node
/**
 * Base MCP Server Template - TypeScript/Node.js Implementation
 * Generated by MCP Server Creation System
 *
 * This template provides a foundation for creating MCP servers with:
 * - Tool execution capabilities
 * - Resource access functionality
 * - Dynamic prompt templates
 * - Comprehensive error handling
 * - Logging and monitoring
 * - Security best practices
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  ListToolsRequestSchema,
  CallToolRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
  Tool,
  Resource,
  Prompt,
  TextContent,
  PromptMessage,
  GetPromptResult
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';

/**
 * {ServerDescription}
 *
 * This server provides:
 * - {ToolsDescription}
 * - {ResourcesDescription}
 * - {PromptsDescription}
 */
export class {ServerClassName} {
  private server: Server;
  private config: Record<string, any>;

  constructor(config: Record<string, any> = {}) {
    this.config = config;
    this.server = new Server({
      name: '{server_name}',
      version: '1.0.0',
    }, {
      capabilities: {
        tools: {has_tools} ? {} : undefined,
        resources: {has_resources} ? {} : undefined,
        prompts: {has_prompts} ? {} : undefined,
        logging: {},
      },
    });

    this.setupHandlers();
    console.log(`Initialized ${this.constructor.name} server`);
  }

  private setupHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      const tools: Tool[] = [
        {tools_list}
      ];
      return { tools };
    });

    // Handle tool execution
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      try {
        console.log(`Executing tool: ${name} with args:`, args);

        {tool_handlers}

        else {
          throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        console.error(`Error executing tool ${name}:`, error);
        return {
          content: [{
            type: 'text' as const,
            text: `Error executing ${name}: ${error instanceof Error ? error.message : String(error)}`
          }]
        };
      }
    });

    // List available resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => {
      const resources: Resource[] = [
        {resources_list}
      ];
      return { resources };
    });

    // Handle resource reading
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const { uri } = request.params;
      
      try {
        console.log(`Reading resource: ${uri}`);

        {resource_handlers}

        else {
          throw new Error(`Unknown resource URI: ${uri}`);
        }
      } catch (error) {
        console.error(`Error reading resource ${uri}:`, error);
        throw error;
      }
    });

    // List available prompts
    this.server.setRequestHandler(ListPromptsRequestSchema, async () => {
      const prompts: Prompt[] = [
        {prompts_list}
      ];
      return { prompts };
    });

    // Handle prompt retrieval
    this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      try {
        console.log(`Getting prompt: ${name} with args:`, args);

        {prompt_handlers}

        else {
          throw new Error(`Unknown prompt: ${name}`);
        }
      } catch (error) {
        console.error(`Error getting prompt ${name}:`, error);
        throw error;
      }
    });
  }

  private async {example_tool_method}(args: Record<string, any>): Promise<{ content: TextContent[] }> {
    /**
     * Example tool implementation.
     * Replace with your specific tool logic.
     */
    // Implement your tool logic here
    const result = 'Example tool result';

    return {
      content: [{
        type: 'text',
        text: result
      }]
    };
  }

  private async {example_resource_method}(uri: string): Promise<{ contents: Array<{ uri: string; mimeType?: string; text: string }> }> {
    /**
     * Example resource implementation.
     * Replace with your specific resource logic.
     */
    // Implement your resource logic here
    return {
      contents: [{
        uri,
        mimeType: 'text/plain',
        text: `Resource content for ${uri}`
      }]
    };
  }

  private async {example_prompt_method}(args: Record<string, string>): Promise<GetPromptResult> {
    /**
     * Example prompt implementation.
     * Replace with your specific prompt logic.
     */
    // Implement your prompt logic here
    const messages: PromptMessage[] = [{
      role: 'user',
      content: {
        type: 'text',
        text: 'Example prompt content'
      }
    }];

    return { messages };
  }

  private validateConfig(): boolean {
    const requiredKeys = {required_config_keys};
    const missingKeys = requiredKeys.filter(key => !(key in this.config));

    if (missingKeys.length > 0) {
      console.error(`Missing required configuration keys: ${missingKeys.join(', ')}`);
      return false;
    }

    return true;
  }

  public async healthCheck(): Promise<Record<string, any>> {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      configValid: this.validateConfig()
    };
  }

  public async run(): Promise<void> {
    if (!this.validateConfig()) {
      console.error('Invalid configuration, server cannot start');
      return;
    }

    console.log('Starting MCP server...');

    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.log(`{ServerClassName} running on stdio`);
  }
}

// CLI interface
async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const configIndex = args.indexOf('--config');
  const debugMode = args.includes('--debug');

  if (debugMode) {
    console.log('Debug mode enabled');
  }

  let config = {};
  if (configIndex !== -1 && configIndex + 1 < args.length) {
    try {
      const fs = await import('fs/promises');
      const configFile = await fs.readFile(args[configIndex + 1], 'utf-8');
      config = JSON.parse(configFile);
    } catch (error) {
      console.error('Failed to load config file:', error);
      process.exit(1);
    }
  }

  const server = new {ServerClassName}(config);

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('Server stopped by user');
    process.exit(0);
  });

  process.on('SIGTERM', () => {
    console.log('Server terminated');
    process.exit(0);
  });

  try {
    await server.run();
  } catch (error) {
    console.error('Server error:', error);
    process.exit(1);
  }
}

// Run if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}