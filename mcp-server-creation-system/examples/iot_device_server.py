#!/usr/bin/env python3
"""
IoT Device Management MCP Server
Generated by MCP Server Creation System

This server provides comprehensive IoT device management capabilities including
device discovery, control, monitoring, and data collection from various IoT platforms.

Capabilities:
- Smart home device control (lights, thermostats, sensors)
- Industrial IoT monitoring and control
- Device discovery and registration
- Sensor data collection and aggregation  
- Firmware update management
- Device health monitoring and alerts
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, timedelta
import json
import httpx
import struct
from dataclasses import dataclass
import uuid

from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializeResult
import mcp.server.stdio
import mcp.types as types

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class IoTDevice:
    """Represents an IoT device."""
    device_id: str
    name: str
    device_type: str
    manufacturer: str
    model: str
    status: str  # online, offline, error
    last_seen: datetime
    properties: Dict[str, Any]
    capabilities: List[str]
    location: Optional[str] = None
    firmware_version: Optional[str] = None

@dataclass
class SensorReading:
    """Represents a sensor reading."""
    device_id: str
    sensor_type: str
    value: Union[float, int, str, bool]
    unit: str
    timestamp: datetime
    quality: str = "good"  # good, bad, uncertain

class IoTDeviceServer:
    """
    IoT Device Management MCP Server for smart device integration.
    
    This server provides:
    - Device discovery and management
    - Real-time device control
    - Sensor data collection
    - Device health monitoring
    - Firmware update management
    - Automation rule execution
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the IoT Device MCP server with optional configuration."""
        self.config = config or {}
        self.server = Server("iot-device-server")
        
        # IoT platform configuration
        self.platforms = self.config.get('platforms', {})
        self.mqtt_broker = self.config.get('mqtt_broker')
        self.device_registry = {}
        self.sensor_data = []
        self.automation_rules = []
        
        self.setup_handlers()
        logger.info("Initialized IoT Device Management Server")
    
    def setup_handlers(self):
        """Setup all MCP handlers for IoT device operations."""
        
        # List available tools
        @self.server.list_tools()
        async def list_tools() -> List[types.Tool]:
            """List all available IoT device tools."""
            return [
                types.Tool(
                    name="discover-devices",
                    description="Discover IoT devices on the network",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "platform": {"type": "string", "enum": ["zigbee", "zwave", "wifi", "bluetooth", "all"], "default": "all"},
                            "timeout": {"type": "integer", "description": "Discovery timeout in seconds", "default": 30},
                            "device_types": {"type": "array", "items": {"type": "string"}, "description": "Filter by device types"}
                        }
                    }
                ),
                types.Tool(
                    name="control-device",
                    description="Control an IoT device (turn on/off, set values, etc.)",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_id": {"type": "string", "description": "Device identifier"},
                            "action": {"type": "string", "enum": ["turn_on", "turn_off", "set_brightness", "set_temperature", "set_color", "custom"]},
                            "value": {"type": ["string", "number", "boolean"], "description": "Value for the action"},
                            "parameters": {"type": "object", "description": "Additional parameters for custom actions"}
                        },
                        "required": ["device_id", "action"]
                    }
                ),
                types.Tool(
                    name="read-sensors",
                    description="Read current values from sensors",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_ids": {"type": "array", "items": {"type": "string"}, "description": "Specific device IDs to read"},
                            "sensor_types": {"type": "array", "items": {"type": "string"}, "description": "Types of sensors to read"},
                            "location": {"type": "string", "description": "Filter by device location"},
                            "include_history": {"type": "boolean", "default": False, "description": "Include historical data"}
                        }
                    }
                ),
                types.Tool(
                    name="monitor-device-health",
                    description="Check the health status of IoT devices",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_ids": {"type": "array", "items": {"type": "string"}, "description": "Specific devices to monitor"},
                            "check_connectivity": {"type": "boolean", "default": True},
                            "check_battery": {"type": "boolean", "default": True},
                            "check_performance": {"type": "boolean", "default": True}
                        }
                    }
                ),
                types.Tool(
                    name="update-firmware",
                    description="Update device firmware",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_id": {"type": "string", "description": "Device to update"},
                            "firmware_version": {"type": "string", "description": "Target firmware version"},
                            "auto_reboot": {"type": "boolean", "default": True, "description": "Automatically reboot after update"},
                            "backup_config": {"type": "boolean", "default": True, "description": "Backup configuration before update"}
                        },
                        "required": ["device_id"]
                    }
                ),
                types.Tool(
                    name="create-automation",
                    description="Create automation rules for device interactions",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "name": {"type": "string", "description": "Rule name"},
                            "trigger": {"type": "object", "description": "Trigger conditions"},
                            "actions": {"type": "array", "items": {"type": "object"}, "description": "Actions to execute"},
                            "enabled": {"type": "boolean", "default": True}
                        },
                        "required": ["name", "trigger", "actions"]
                    }
                ),
                types.Tool(
                    name="configure-device",
                    description="Configure device settings and properties",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_id": {"type": "string", "description": "Device to configure"},
                            "configuration": {"type": "object", "description": "Configuration parameters"},
                            "validate_config": {"type": "boolean", "default": True}
                        },
                        "required": ["device_id", "configuration"]
                    }
                ),
                types.Tool(
                    name="get-device-analytics",
                    description="Get analytics and usage statistics for devices",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "device_ids": {"type": "array", "items": {"type": "string"}},
                            "metric_types": {"type": "array", "items": {"type": "string"}, "description": "Types of metrics to retrieve"},
                            "time_range": {"type": "string", "enum": ["1hour", "1day", "1week", "1month"], "default": "1day"},
                            "aggregation": {"type": "string", "enum": ["avg", "min", "max", "sum", "count"], "default": "avg"}
                        }
                    }
                )
            ]
        
        # Handle tool execution
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Optional[Dict[str, Any]]) -> List[types.TextContent]:
            """Execute an IoT device tool with the given arguments."""
            try:
                logger.info(f"Executing IoT tool: {name} with args: {arguments}")
                
                if name == "discover-devices":
                    return await self.discover_devices(**arguments or {})
                elif name == "control-device":
                    return await self.control_device(**arguments or {})
                elif name == "read-sensors":
                    return await self.read_sensors(**arguments or {})
                elif name == "monitor-device-health":
                    return await self.monitor_device_health(**arguments or {})
                elif name == "update-firmware":
                    return await self.update_firmware(**arguments or {})
                elif name == "create-automation":
                    return await self.create_automation(**arguments or {})
                elif name == "configure-device":
                    return await self.configure_device(**arguments or {})
                elif name == "get-device-analytics":
                    return await self.get_device_analytics(**arguments or {})
                else:
                    raise ValueError(f"Unknown IoT tool: {name}")
                    
            except Exception as e:
                logger.error(f"Error executing IoT tool {name}: {str(e)}")
                return [types.TextContent(
                    type="text", 
                    text=f"Error executing {name}: {str(e)}"
                )]
        
        # List available resources
        @self.server.list_resources()
        async def list_resources() -> List[types.Resource]:
            """List all available IoT resources."""
            return [
                types.Resource(
                    uri="iot://device-registry",
                    name="Device Registry",
                    description="Registry of all managed IoT devices",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="iot://sensor-data",
                    name="Sensor Data Stream",
                    description="Live sensor data from all devices",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="iot://device-templates",
                    name="Device Configuration Templates",
                    description="Templates for common device types and configurations",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="iot://automation-rules",
                    name="Automation Rules",
                    description="Active automation rules and scenarios",
                    mimeType="application/json"
                )
            ]
        
        # Handle resource reading
        @self.server.read_resource()
        async def read_resource(uri: str) -> str:
            """Read IoT resource content."""
            try:
                logger.info(f"Reading IoT resource: {uri}")
                
                if uri == "iot://device-registry":
                    return await self.get_device_registry()
                elif uri == "iot://sensor-data":
                    return await self.get_sensor_data_stream()
                elif uri == "iot://device-templates":
                    return await self.get_device_templates()
                elif uri == "iot://automation-rules":
                    return await self.get_automation_rules()
                else:
                    raise ValueError(f"Unknown IoT resource URI: {uri}")
                    
            except Exception as e:
                logger.error(f"Error reading IoT resource {uri}: {str(e)}")
                raise
    
    async def discover_devices(self, platform: str = "all", timeout: int = 30, 
                             device_types: Optional[List[str]] = None) -> List[types.TextContent]:
        """Discover IoT devices on the network."""
        try:
            discovered_devices = []
            
            # Simulate device discovery for different platforms
            if platform in ["all", "wifi"]:
                wifi_devices = await self._discover_wifi_devices(timeout)
                discovered_devices.extend(wifi_devices)
            
            if platform in ["all", "zigbee"]:
                zigbee_devices = await self._discover_zigbee_devices(timeout)
                discovered_devices.extend(zigbee_devices)
            
            if platform in ["all", "zwave"]:
                zwave_devices = await self._discover_zwave_devices(timeout)
                discovered_devices.extend(zwave_devices)
            
            if platform in ["all", "bluetooth"]:
                bluetooth_devices = await self._discover_bluetooth_devices(timeout)
                discovered_devices.extend(bluetooth_devices)
            
            # Filter by device types if specified
            if device_types:
                discovered_devices = [d for d in discovered_devices if d["device_type"] in device_types]
            
            # Update device registry
            for device in discovered_devices:
                self.device_registry[device["device_id"]] = device
            
            result = {
                "total_discovered": len(discovered_devices),
                "platforms_scanned": [platform] if platform != "all" else ["wifi", "zigbee", "zwave", "bluetooth"],
                "devices": discovered_devices
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Device discovery error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Device discovery failed: {str(e)}"
            )]
    
    async def control_device(self, device_id: str, action: str, value: Optional[Union[str, int, bool]] = None,
                           parameters: Optional[Dict[str, Any]] = None) -> List[types.TextContent]:
        """Control an IoT device."""
        try:
            if device_id not in self.device_registry:
                raise ValueError(f"Device {device_id} not found in registry")
            
            device = self.device_registry[device_id]
            
            # Execute device control action
            control_result = await self._execute_device_action(device, action, value, parameters)
            
            # Update device status
            device["last_controlled"] = datetime.utcnow()
            device["last_action"] = {"action": action, "value": value, "timestamp": datetime.utcnow()}
            
            result = {
                "device_id": device_id,
                "device_name": device["name"],
                "action": action,
                "value": value,
                "result": control_result,
                "timestamp": datetime.utcnow().isoformat(),
                "status": "success"
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Device control error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Device control failed: {str(e)}"
            )]
    
    async def read_sensors(self, device_ids: Optional[List[str]] = None, 
                         sensor_types: Optional[List[str]] = None,
                         location: Optional[str] = None, 
                         include_history: bool = False) -> List[types.TextContent]:
        """Read current values from sensors."""
        try:
            sensor_readings = []
            
            # Filter devices based on criteria
            devices_to_read = []
            for device_id, device in self.device_registry.items():
                # Filter by device IDs
                if device_ids and device_id not in device_ids:
                    continue
                
                # Filter by location
                if location and device.get("location") != location:
                    continue
                
                # Check if device has sensors
                if "sensor" in device.get("capabilities", []):
                    devices_to_read.append(device)
            
            # Read sensor data from selected devices
            for device in devices_to_read:
                readings = await self._read_device_sensors(device, sensor_types)
                sensor_readings.extend(readings)
            
            # Include historical data if requested
            historical_data = []
            if include_history:
                historical_data = await self._get_historical_sensor_data(device_ids, sensor_types, location)
            
            result = {
                "timestamp": datetime.utcnow().isoformat(),
                "total_readings": len(sensor_readings),
                "current_readings": sensor_readings,
                "historical_data": historical_data if include_history else None
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Sensor reading error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Sensor reading failed: {str(e)}"
            )]
    
    async def monitor_device_health(self, device_ids: Optional[List[str]] = None,
                                  check_connectivity: bool = True,
                                  check_battery: bool = True,
                                  check_performance: bool = True) -> List[types.TextContent]:
        """Check the health status of IoT devices."""
        try:
            health_reports = []
            
            devices_to_check = device_ids if device_ids else list(self.device_registry.keys())
            
            for device_id in devices_to_check:
                if device_id not in self.device_registry:
                    continue
                
                device = self.device_registry[device_id]
                health_info = {
                    "device_id": device_id,
                    "device_name": device["name"],
                    "overall_health": "unknown",
                    "checks": {}
                }
                
                issues = []
                
                # Connectivity check
                if check_connectivity:
                    connectivity_status = await self._check_device_connectivity(device)
                    health_info["checks"]["connectivity"] = connectivity_status
                    if connectivity_status["status"] != "online":
                        issues.append("connectivity")
                
                # Battery check
                if check_battery and "battery" in device.get("properties", {}):
                    battery_status = await self._check_device_battery(device)
                    health_info["checks"]["battery"] = battery_status
                    if battery_status["level"] < 20:
                        issues.append("low_battery")
                
                # Performance check
                if check_performance:
                    performance_status = await self._check_device_performance(device)
                    health_info["checks"]["performance"] = performance_status
                    if performance_status["status"] != "good":
                        issues.append("performance")
                
                # Overall health assessment
                if not issues:
                    health_info["overall_health"] = "healthy"
                elif len(issues) == 1:
                    health_info["overall_health"] = "warning"
                else:
                    health_info["overall_health"] = "critical"
                
                health_info["issues"] = issues
                health_info["last_check"] = datetime.utcnow().isoformat()
                
                health_reports.append(health_info)
            
            result = {
                "total_devices_checked": len(health_reports),
                "healthy_devices": len([r for r in health_reports if r["overall_health"] == "healthy"]),
                "warning_devices": len([r for r in health_reports if r["overall_health"] == "warning"]),
                "critical_devices": len([r for r in health_reports if r["overall_health"] == "critical"]),
                "device_reports": health_reports
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Health monitoring error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Health monitoring failed: {str(e)}"
            )]
    
    async def update_firmware(self, device_id: str, firmware_version: Optional[str] = None,
                            auto_reboot: bool = True, backup_config: bool = True) -> List[types.TextContent]:
        """Update device firmware."""
        try:
            if device_id not in self.device_registry:
                raise ValueError(f"Device {device_id} not found in registry")
            
            device = self.device_registry[device_id]
            current_version = device.get("firmware_version", "unknown")
            
            # Get latest firmware version if not specified
            if not firmware_version:
                firmware_version = await self._get_latest_firmware_version(device)
            
            # Check if update is needed
            if current_version == firmware_version:
                return [types.TextContent(
                    type="text",
                    text=json.dumps({
                        "device_id": device_id,
                        "status": "no_update_needed",
                        "current_version": current_version,
                        "requested_version": firmware_version
                    }, indent=2)
                )]
            
            update_result = {
                "device_id": device_id,
                "device_name": device["name"],
                "current_version": current_version,
                "target_version": firmware_version,
                "status": "in_progress",
                "steps": []
            }
            
            # Backup configuration if requested
            if backup_config:
                backup_result = await self._backup_device_config(device)
                update_result["steps"].append({
                    "step": "backup_config",
                    "status": "completed" if backup_result else "failed",
                    "timestamp": datetime.utcnow().isoformat()
                })
            
            # Download firmware
            download_result = await self._download_firmware(device, firmware_version)
            update_result["steps"].append({
                "step": "download_firmware",
                "status": "completed" if download_result else "failed",
                "timestamp": datetime.utcnow().isoformat()
            })
            
            if not download_result:
                update_result["status"] = "failed"
                update_result["error"] = "Failed to download firmware"
            else:
                # Install firmware
                install_result = await self._install_firmware(device, firmware_version)
                update_result["steps"].append({
                    "step": "install_firmware",
                    "status": "completed" if install_result else "failed",
                    "timestamp": datetime.utcnow().isoformat()
                })
                
                if install_result:
                    # Update device registry
                    device["firmware_version"] = firmware_version
                    device["last_firmware_update"] = datetime.utcnow()
                    
                    # Reboot device if requested
                    if auto_reboot:
                        reboot_result = await self._reboot_device(device)
                        update_result["steps"].append({
                            "step": "reboot_device",
                            "status": "completed" if reboot_result else "failed",
                            "timestamp": datetime.utcnow().isoformat()
                        })
                    
                    update_result["status"] = "completed"
                else:
                    update_result["status"] = "failed"
                    update_result["error"] = "Failed to install firmware"
            
            return [types.TextContent(
                type="text",
                text=json.dumps(update_result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Firmware update error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Firmware update failed: {str(e)}"
            )]
    
    async def create_automation(self, name: str, trigger: Dict[str, Any], 
                              actions: List[Dict[str, Any]], enabled: bool = True) -> List[types.TextContent]:
        """Create automation rules for device interactions."""
        try:
            # Generate unique automation ID
            automation_id = str(uuid.uuid4())
            
            # Validate trigger conditions
            trigger_valid = await self._validate_trigger(trigger)
            if not trigger_valid:
                raise ValueError("Invalid trigger configuration")
            
            # Validate actions
            for action in actions:
                action_valid = await self._validate_action(action)
                if not action_valid:
                    raise ValueError(f"Invalid action configuration: {action}")
            
            # Create automation rule
            automation_rule = {
                "id": automation_id,
                "name": name,
                "trigger": trigger,
                "actions": actions,
                "enabled": enabled,
                "created_at": datetime.utcnow().isoformat(),
                "last_triggered": None,
                "execution_count": 0
            }
            
            # Add to automation rules
            self.automation_rules.append(automation_rule)
            
            result = {
                "automation_id": automation_id,
                "name": name,
                "status": "created",
                "enabled": enabled,
                "trigger_type": trigger.get("type"),
                "action_count": len(actions),
                "created_at": automation_rule["created_at"]
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Automation creation error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Automation creation failed: {str(e)}"
            )]
    
    async def configure_device(self, device_id: str, configuration: Dict[str, Any],
                             validate_config: bool = True) -> List[types.TextContent]:
        """Configure device settings and properties."""
        try:
            if device_id not in self.device_registry:
                raise ValueError(f"Device {device_id} not found in registry")
            
            device = self.device_registry[device_id]
            
            # Validate configuration if requested
            if validate_config:
                validation_result = await self._validate_device_config(device, configuration)
                if not validation_result["valid"]:
                    raise ValueError(f"Invalid configuration: {validation_result['errors']}")
            
            # Apply configuration
            config_result = await self._apply_device_config(device, configuration)
            
            # Update device registry
            if "properties" not in device:
                device["properties"] = {}
            device["properties"].update(configuration)
            device["last_configured"] = datetime.utcnow()
            
            result = {
                "device_id": device_id,
                "device_name": device["name"],
                "configuration_applied": configuration,
                "status": "success" if config_result else "failed",
                "timestamp": datetime.utcnow().isoformat()
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Device configuration error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Device configuration failed: {str(e)}"
            )]
    
    async def get_device_analytics(self, device_ids: Optional[List[str]] = None,
                                 metric_types: Optional[List[str]] = None,
                                 time_range: str = "1day",
                                 aggregation: str = "avg") -> List[types.TextContent]:
        """Get analytics and usage statistics for devices."""
        try:
            devices_to_analyze = device_ids if device_ids else list(self.device_registry.keys())
            
            analytics_data = {
                "time_range": time_range,
                "aggregation": aggregation,
                "generated_at": datetime.utcnow().isoformat(),
                "device_analytics": []
            }
            
            for device_id in devices_to_analyze:
                if device_id not in self.device_registry:
                    continue
                
                device = self.device_registry[device_id]
                device_analytics = await self._get_device_metrics(device, metric_types, time_range, aggregation)
                
                analytics_data["device_analytics"].append({
                    "device_id": device_id,
                    "device_name": device["name"],
                    "device_type": device["device_type"],
                    "metrics": device_analytics
                })
            
            return [types.TextContent(
                type="text",
                text=json.dumps(analytics_data, indent=2, default=str)
            )]
            
        except Exception as e:
            logger.error(f"Analytics retrieval error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Analytics retrieval failed: {str(e)}"
            )]
    
    # Resource methods
    async def get_device_registry(self) -> str:
        """Get the complete device registry."""
        registry_data = {
            "total_devices": len(self.device_registry),
            "last_updated": datetime.utcnow().isoformat(),
            "devices": list(self.device_registry.values())
        }
        
        return json.dumps(registry_data, indent=2, default=str)
    
    async def get_sensor_data_stream(self) -> str:
        """Get live sensor data from all devices."""
        current_readings = []
        
        for device_id, device in self.device_registry.items():
            if "sensor" in device.get("capabilities", []):
                readings = await self._read_device_sensors(device, None)
                current_readings.extend(readings)
        
        stream_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "total_readings": len(current_readings),
            "readings": current_readings
        }
        
        return json.dumps(stream_data, indent=2, default=str)
    
    async def get_device_templates(self) -> str:
        """Get device configuration templates."""
        templates = {
            "smart_light": {
                "device_type": "light",
                "capabilities": ["switch", "brightness", "color"],
                "default_properties": {
                    "brightness": 100,
                    "color": "#FFFFFF",
                    "power_on_behavior": "last_state"
                },
                "configuration_schema": {
                    "brightness": {"type": "integer", "min": 0, "max": 100},
                    "color": {"type": "string", "pattern": "^#[0-9A-Fa-f]{6}$"},
                    "power_on_behavior": {"type": "string", "enum": ["on", "off", "last_state"]}
                }
            },
            "smart_thermostat": {
                "device_type": "thermostat",
                "capabilities": ["temperature_control", "sensor", "scheduling"],
                "default_properties": {
                    "target_temperature": 22,
                    "mode": "auto",
                    "schedule_enabled": True
                },
                "configuration_schema": {
                    "target_temperature": {"type": "number", "min": 5, "max": 35},
                    "mode": {"type": "string", "enum": ["heat", "cool", "auto", "off"]},
                    "schedule_enabled": {"type": "boolean"}
                }
            },
            "motion_sensor": {
                "device_type": "sensor",
                "capabilities": ["sensor", "battery"],
                "default_properties": {
                    "sensitivity": "medium",
                    "timeout": 300
                },
                "configuration_schema": {
                    "sensitivity": {"type": "string", "enum": ["low", "medium", "high"]},
                    "timeout": {"type": "integer", "min": 30, "max": 3600}
                }
            },
            "smart_plug": {
                "device_type": "switch",
                "capabilities": ["switch", "power_monitoring"],
                "default_properties": {
                    "auto_off": False,
                    "auto_off_delay": 0
                },
                "configuration_schema": {
                    "auto_off": {"type": "boolean"},
                    "auto_off_delay": {"type": "integer", "min": 0, "max": 86400}
                }
            }
        }
        
        return json.dumps(templates, indent=2)
    
    async def get_automation_rules(self) -> str:
        """Get active automation rules."""
        rules_data = {
            "total_rules": len(self.automation_rules),
            "active_rules": len([r for r in self.automation_rules if r["enabled"]]),
            "last_updated": datetime.utcnow().isoformat(),
            "rules": self.automation_rules
        }
        
        return json.dumps(rules_data, indent=2, default=str)
    
    # Helper methods for device operations
    async def _discover_wifi_devices(self, timeout: int) -> List[Dict[str, Any]]:
        """Discover WiFi-based IoT devices."""
        # Simulate WiFi device discovery
        devices = [
            {
                "device_id": "wifi_light_001",
                "name": "Living Room Light",
                "device_type": "light",
                "manufacturer": "Philips",
                "model": "Hue White",
                "platform": "wifi",
                "status": "online",
                "capabilities": ["switch", "brightness"],
                "properties": {"brightness": 80, "state": "on"},
                "last_seen": datetime.utcnow(),
                "firmware_version": "1.2.3"
            },
            {
                "device_id": "wifi_thermostat_001",
                "name": "Main Thermostat",
                "device_type": "thermostat",
                "manufacturer": "Nest",
                "model": "Learning Thermostat",
                "platform": "wifi",
                "status": "online",
                "capabilities": ["temperature_control", "sensor"],
                "properties": {"temperature": 22.5, "target": 23.0, "mode": "heat"},
                "last_seen": datetime.utcnow(),
                "firmware_version": "2.1.0"
            }
        ]
        
        return devices
    
    async def _discover_zigbee_devices(self, timeout: int) -> List[Dict[str, Any]]:
        """Discover Zigbee devices."""
        devices = [
            {
                "device_id": "zigbee_sensor_001",
                "name": "Kitchen Motion Sensor",
                "device_type": "sensor",
                "manufacturer": "Xiaomi",
                "model": "Aqara Motion Sensor",
                "platform": "zigbee",
                "status": "online",
                "capabilities": ["sensor", "battery"],
                "properties": {"motion": False, "battery": 85},
                "last_seen": datetime.utcnow(),
                "firmware_version": "1.0.5"
            }
        ]
        
        return devices
    
    async def _discover_zwave_devices(self, timeout: int) -> List[Dict[str, Any]]:
        """Discover Z-Wave devices."""
        devices = [
            {
                "device_id": "zwave_plug_001",
                "name": "Bedroom Smart Plug",
                "device_type": "switch",
                "manufacturer": "Aeotec",
                "model": "Smart Switch 6",
                "platform": "zwave",
                "status": "online",
                "capabilities": ["switch", "power_monitoring"],
                "properties": {"state": "off", "power": 0.0},
                "last_seen": datetime.utcnow(),
                "firmware_version": "3.2.1"
            }
        ]
        
        return devices
    
    async def _discover_bluetooth_devices(self, timeout: int) -> List[Dict[str, Any]]:
        """Discover Bluetooth devices."""
        devices = [
            {
                "device_id": "ble_tracker_001",
                "name": "Key Tracker",
                "device_type": "tracker",
                "manufacturer": "Tile",
                "model": "Tile Pro",
                "platform": "bluetooth",
                "status": "online",
                "capabilities": ["location", "battery"],
                "properties": {"battery": 60, "last_location": "home"},
                "last_seen": datetime.utcnow(),
                "firmware_version": "1.1.2"
            }
        ]
        
        return devices
    
    async def _execute_device_action(self, device: Dict[str, Any], action: str, 
                                   value: Optional[Union[str, int, bool]] = None,
                                   parameters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute a control action on a device."""
        # Simulate device control
        result = {"action_executed": True, "previous_state": device.get("properties", {})}
        
        if action == "turn_on":
            if "properties" not in device:
                device["properties"] = {}
            device["properties"]["state"] = "on"
            result["new_state"] = "on"
            
        elif action == "turn_off":
            if "properties" not in device:
                device["properties"] = {}
            device["properties"]["state"] = "off"
            result["new_state"] = "off"
            
        elif action == "set_brightness" and value is not None:
            if "properties" not in device:
                device["properties"] = {}
            device["properties"]["brightness"] = int(value)
            result["new_brightness"] = int(value)
            
        elif action == "set_temperature" and value is not None:
            if "properties" not in device:
                device["properties"] = {}
            device["properties"]["target_temperature"] = float(value)
            result["new_target_temperature"] = float(value)
        
        return result
    
    async def _read_device_sensors(self, device: Dict[str, Any], 
                                 sensor_types: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        """Read sensor values from a device."""
        readings = []
        
        # Simulate sensor readings based on device type
        if device["device_type"] == "sensor":
            if "motion" in device.get("properties", {}):
                readings.append({
                    "device_id": device["device_id"],
                    "sensor_type": "motion",
                    "value": device["properties"]["motion"],
                    "unit": "boolean",
                    "timestamp": datetime.utcnow().isoformat(),
                    "quality": "good"
                })
            
            if "temperature" in device.get("properties", {}):
                readings.append({
                    "device_id": device["device_id"],
                    "sensor_type": "temperature",
                    "value": device["properties"]["temperature"],
                    "unit": "°C",
                    "timestamp": datetime.utcnow().isoformat(),
                    "quality": "good"
                })
        
        elif device["device_type"] == "thermostat":
            readings.append({
                "device_id": device["device_id"],
                "sensor_type": "temperature",
                "value": device.get("properties", {}).get("temperature", 20.0),
                "unit": "°C",
                "timestamp": datetime.utcnow().isoformat(),
                "quality": "good"
            })
        
        # Filter by sensor types if specified
        if sensor_types:
            readings = [r for r in readings if r["sensor_type"] in sensor_types]
        
        return readings
    
    async def _check_device_connectivity(self, device: Dict[str, Any]) -> Dict[str, Any]:
        """Check device connectivity status."""
        # Simulate connectivity check
        last_seen = device.get("last_seen", datetime.utcnow() - timedelta(hours=1))
        if isinstance(last_seen, str):
            last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00'))
        
        time_since_last_seen = datetime.utcnow() - last_seen.replace(tzinfo=None)
        
        if time_since_last_seen < timedelta(minutes=5):
            status = "online"
        elif time_since_last_seen < timedelta(hours=1):
            status = "warning"
        else:
            status = "offline"
        
        return {
            "status": status,
            "last_seen": last_seen.isoformat(),
            "time_since_last_seen_seconds": int(time_since_last_seen.total_seconds())
        }
    
    async def _check_device_battery(self, device: Dict[str, Any]) -> Dict[str, Any]:
        """Check device battery status."""
        battery_level = device.get("properties", {}).get("battery", 100)
        
        if battery_level > 50:
            status = "good"
        elif battery_level > 20:
            status = "warning"
        else:
            status = "critical"
        
        return {
            "level": battery_level,
            "status": status,
            "estimated_days_remaining": max(1, battery_level // 5)  # Rough estimate
        }
    
    async def _check_device_performance(self, device: Dict[str, Any]) -> Dict[str, Any]:
        """Check device performance metrics."""
        # Simulate performance check
        response_time = device.get("properties", {}).get("response_time_ms", 50)
        error_rate = device.get("properties", {}).get("error_rate", 0.0)
        
        if response_time < 100 and error_rate < 0.01:
            status = "good"
        elif response_time < 500 and error_rate < 0.05:
            status = "warning"
        else:
            status = "poor"
        
        return {
            "status": status,
            "response_time_ms": response_time,
            "error_rate": error_rate,
            "uptime_hours": device.get("properties", {}).get("uptime_hours", 24)
        }
    
    def validate_config(self) -> bool:
        """Validate server configuration."""
        # IoT server can work with minimal configuration
        return True
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check and return status."""
        total_devices = len(self.device_registry)
        online_devices = len([d for d in self.device_registry.values() if d.get("status") == "online"])
        
        return {
            "status": "healthy",
            "total_devices": total_devices,
            "online_devices": online_devices,
            "offline_devices": total_devices - online_devices,
            "automation_rules": len(self.automation_rules),
            "active_automations": len([r for r in self.automation_rules if r["enabled"]]),
            "timestamp": datetime.utcnow().isoformat(),
            "version": "1.0.0",
            "config_valid": self.validate_config()
        }
    
    # Additional helper methods would be implemented here for:
    # - _get_historical_sensor_data
    # - _get_latest_firmware_version
    # - _backup_device_config
    # - _download_firmware
    # - _install_firmware
    # - _reboot_device
    # - _validate_trigger
    # - _validate_action
    # - _validate_device_config
    # - _apply_device_config
    # - _get_device_metrics
    
    async def run(self):
        """Run the IoT Device MCP server."""
        if not self.validate_config():
            logger.error("Invalid configuration, server cannot start")
            return
        
        logger.info("Starting IoT Device Management MCP server...")
        
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream, 
                write_stream, 
                InitializeResult(
                    protocolVersion="2024-11-05",
                    capabilities=types.ServerCapabilities(
                        tools={},
                        resources={},
                        logging={}
                    ),
                    serverInfo=types.Implementation(
                        name="iot-device-server",
                        version="1.0.0"
                    )
                )
            )

async def main():
    """Main entry point for the IoT Device server."""
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(description="IoT Device Management MCP Server")
    parser.add_argument("--config", type=str, help="Path to configuration file")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("--mqtt-broker", type=str, help="MQTT broker URL")
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    config = {}
    if args.config:
        try:
            with open(args.config, 'r') as f:
                config = json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config file: {e}")
            sys.exit(1)
    
    # Override config with command line arguments
    if args.mqtt_broker:
        config['mqtt_broker'] = args.mqtt_broker
    
    server = IoTDeviceServer(config)
    
    try:
        await server.run()
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
    except Exception as e:
        logger.error(f"Server error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())