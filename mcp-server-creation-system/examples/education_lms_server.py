#!/usr/bin/env python3
"""
Education LMS MCP Server
Generated by MCP Server Creation System

This server provides Learning Management System integration for educational institutions,
supporting Canvas, Blackboard, Moodle, and other popular LMS platforms.

Capabilities:
- Student enrollment management
- Course content delivery
- Assignment submission tracking
- Grade synchronization
- Learning analytics
- Discussion forums
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, timedelta
import json
import httpx
from urllib.parse import urljoin, urlencode
import base64

from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializeResult
import mcp.server.stdio
import mcp.types as types

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class EducationLmsServer:
    """
    Education LMS MCP Server for educational platform integration.
    
    This server provides:
    - Student and enrollment management
    - Course content access
    - Assignment and grade management
    - Discussion forum interaction
    - Learning analytics and reporting
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize the LMS MCP server with optional configuration."""
        self.config = config or {}
        self.server = Server("education-lms-server")
        
        # LMS configuration
        self.lms_base_url = self.config.get('lms_base_url', 'https://canvas.instructure.com')
        self.api_token = self.config.get('api_token')
        self.lms_type = self.config.get('lms_type', 'canvas')  # canvas, blackboard, moodle
        self.timeout = self.config.get('timeout', 30)
        
        self.setup_handlers()
        logger.info(f"Initialized Education LMS Server ({self.lms_type})")
    
    def setup_handlers(self):
        """Setup all MCP handlers for LMS operations."""
        
        # List available tools
        @self.server.list_tools()
        async def list_tools() -> List[types.Tool]:
            """List all available LMS tools."""
            return [
                types.Tool(
                    name="get-courses",
                    description="Get list of courses for a user or institution",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "user_id": {"type": "string", "description": "User ID (optional)"},
                            "enrollment_type": {"type": "string", "enum": ["student", "teacher", "observer", "ta"], "description": "Filter by enrollment type"},
                            "include_concluded": {"type": "boolean", "default": False, "description": "Include concluded courses"},
                            "limit": {"type": "integer", "description": "Maximum results to return", "default": 20}
                        }
                    }
                ),
                types.Tool(
                    name="get-course-content",
                    description="Get course content including modules, lessons, and materials",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "include_modules": {"type": "boolean", "default": True},
                            "include_assignments": {"type": "boolean", "default": True},
                            "include_announcements": {"type": "boolean", "default": False}
                        },
                        "required": ["course_id"]
                    }
                ),
                types.Tool(
                    name="enroll-student",
                    description="Enroll a student in a course",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "user_id": {"type": "string", "description": "Student user ID"},
                            "enrollment_type": {"type": "string", "enum": ["StudentEnrollment", "TeacherEnrollment", "TaEnrollment", "ObserverEnrollment"], "default": "StudentEnrollment"},
                            "enrollment_state": {"type": "string", "enum": ["active", "invited", "inactive"], "default": "active"}
                        },
                        "required": ["course_id", "user_id"]
                    }
                ),
                types.Tool(
                    name="submit-assignment",
                    description="Submit an assignment for a student",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "assignment_id": {"type": "string", "description": "Assignment ID"},
                            "user_id": {"type": "string", "description": "Student user ID"},
                            "submission_type": {"type": "string", "enum": ["online_text_entry", "online_upload", "online_url", "media_recording"], "default": "online_text_entry"},
                            "body": {"type": "string", "description": "Submission content/text"},
                            "url": {"type": "string", "description": "URL for online_url submissions"},
                            "file_ids": {"type": "array", "items": {"type": "string"}, "description": "File IDs for upload submissions"}
                        },
                        "required": ["course_id", "assignment_id", "user_id"]
                    }
                ),
                types.Tool(
                    name="get-grades",
                    description="Get grades for a student or course",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "user_id": {"type": "string", "description": "Student user ID"},
                            "assignment_id": {"type": "string", "description": "Specific assignment ID (optional)"},
                            "grading_period_id": {"type": "string", "description": "Grading period ID (optional)"}
                        }
                    }
                ),
                types.Tool(
                    name="update-grade",
                    description="Update a grade for an assignment submission",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "assignment_id": {"type": "string", "description": "Assignment ID"},
                            "user_id": {"type": "string", "description": "Student user ID"},
                            "grade": {"type": ["string", "number"], "description": "Grade value"},
                            "comment": {"type": "string", "description": "Feedback comment"},
                            "rubric_assessment": {"type": "object", "description": "Rubric assessment data"}
                        },
                        "required": ["course_id", "assignment_id", "user_id", "grade"]
                    }
                ),
                types.Tool(
                    name="create-discussion",
                    description="Create a discussion topic in a course",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "title": {"type": "string", "description": "Discussion topic title"},
                            "message": {"type": "string", "description": "Discussion topic message/description"},
                            "discussion_type": {"type": "string", "enum": ["side_comment", "threaded"], "default": "threaded"},
                            "published": {"type": "boolean", "default": True},
                            "allow_rating": {"type": "boolean", "default": False}
                        },
                        "required": ["course_id", "title", "message"]
                    }
                ),
                types.Tool(
                    name="get-analytics",
                    description="Get learning analytics data for courses and students",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "course_id": {"type": "string", "description": "Course ID"},
                            "user_id": {"type": "string", "description": "User ID (optional)"},
                            "metric": {"type": "string", "enum": ["participation", "page_views", "submissions", "tardiness"], "description": "Analytics metric to retrieve"},
                            "start_date": {"type": "string", "description": "Start date (YYYY-MM-DD)"},
                            "end_date": {"type": "string", "description": "End date (YYYY-MM-DD)"}
                        }
                    }
                ),
                types.Tool(
                    name="sync-gradebook",
                    description="Synchronize gradebook data between systems",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "source_course_id": {"type": "string", "description": "Source course ID"},
                            "target_course_id": {"type": "string", "description": "Target course ID"},
                            "sync_type": {"type": "string", "enum": ["grades_only", "assignments_and_grades", "full_sync"], "default": "grades_only"},
                            "overwrite_existing": {"type": "boolean", "default": False}
                        },
                        "required": ["source_course_id", "target_course_id"]
                    }
                )
            ]
        
        # Handle tool execution
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Optional[Dict[str, Any]]) -> List[types.TextContent]:
            """Execute an LMS tool with the given arguments."""
            try:
                logger.info(f"Executing LMS tool: {name} with args: {arguments}")
                
                if name == "get-courses":
                    return await self.get_courses(**arguments or {})
                elif name == "get-course-content":
                    return await self.get_course_content(**arguments or {})
                elif name == "enroll-student":
                    return await self.enroll_student(**arguments or {})
                elif name == "submit-assignment":
                    return await self.submit_assignment(**arguments or {})
                elif name == "get-grades":
                    return await self.get_grades(**arguments or {})
                elif name == "update-grade":
                    return await self.update_grade(**arguments or {})
                elif name == "create-discussion":
                    return await self.create_discussion(**arguments or {})
                elif name == "get-analytics":
                    return await self.get_analytics(**arguments or {})
                elif name == "sync-gradebook":
                    return await self.sync_gradebook(**arguments or {})
                else:
                    raise ValueError(f"Unknown LMS tool: {name}")
                    
            except Exception as e:
                logger.error(f"Error executing LMS tool {name}: {str(e)}")
                return [types.TextContent(
                    type="text", 
                    text=f"Error executing {name}: {str(e)}"
                )]
        
        # List available resources
        @self.server.list_resources()
        async def list_resources() -> List[types.Resource]:
            """List all available LMS resources."""
            return [
                types.Resource(
                    uri="lms://course-templates",
                    name="Course Templates",
                    description="Standard course templates and structures",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="lms://assignment-rubrics",
                    name="Assignment Rubrics",
                    description="Common assignment rubric templates",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="lms://grade-scales",
                    name="Grading Scales",
                    description="Standard grading scales and conversion tables",
                    mimeType="application/json"
                ),
                types.Resource(
                    uri="lms://analytics-reports",
                    name="Analytics Report Templates",
                    description="Learning analytics report templates",
                    mimeType="application/json"
                )
            ]
        
        # Handle resource reading
        @self.server.read_resource()
        async def read_resource(uri: str) -> str:
            """Read LMS resource content."""
            try:
                logger.info(f"Reading LMS resource: {uri}")
                
                if uri == "lms://course-templates":
                    return await self.get_course_templates()
                elif uri == "lms://assignment-rubrics":
                    return await self.get_assignment_rubrics()
                elif uri == "lms://grade-scales":
                    return await self.get_grade_scales()
                elif uri == "lms://analytics-reports":
                    return await self.get_analytics_reports()
                else:
                    raise ValueError(f"Unknown LMS resource URI: {uri}")
                    
            except Exception as e:
                logger.error(f"Error reading LMS resource {uri}: {str(e)}")
                raise
        
        # List available prompts
        @self.server.list_prompts()
        async def list_prompts() -> List[types.Prompt]:
            """List all available LMS prompts."""
            return [
                types.Prompt(
                    name="assignment-feedback",
                    description="Generate personalized assignment feedback for students",
                    arguments=[
                        {"name": "assignment_title", "description": "Assignment title", "required": True},
                        {"name": "student_submission", "description": "Student's submission content", "required": True},
                        {"name": "rubric_criteria", "description": "Rubric criteria and scores", "required": False},
                        {"name": "tone", "description": "Feedback tone (encouraging, constructive, detailed)", "required": False}
                    ]
                ),
                types.Prompt(
                    name="course-announcement",
                    description="Generate course announcements and communications",
                    arguments=[
                        {"name": "announcement_type", "description": "Type of announcement (reminder, update, welcome)", "required": True},
                        {"name": "course_name", "description": "Course name", "required": True},
                        {"name": "key_points", "description": "Key information to include", "required": True},
                        {"name": "urgency", "description": "Urgency level (low, medium, high)", "required": False}
                    ]
                )
            ]
        
        # Handle prompt retrieval
        @self.server.get_prompt()
        async def get_prompt(name: str, arguments: Optional[Dict[str, str]]) -> types.GetPromptResult:
            """Get an LMS prompt template with arguments."""
            try:
                logger.info(f"Getting LMS prompt: {name} with args: {arguments}")
                
                if name == "assignment-feedback":
                    return await self.get_assignment_feedback_prompt(arguments or {})
                elif name == "course-announcement":
                    return await self.get_course_announcement_prompt(arguments or {})
                else:
                    raise ValueError(f"Unknown LMS prompt: {name}")
                    
            except Exception as e:
                logger.error(f"Error getting LMS prompt {name}: {str(e)}")
                raise
    
    async def get_courses(self, user_id: Optional[str] = None, enrollment_type: Optional[str] = None,
                         include_concluded: bool = False, limit: int = 20) -> List[types.TextContent]:
        """Get list of courses for a user or institution."""
        try:
            params = {"per_page": limit}
            
            if enrollment_type:
                params["enrollment_type"] = enrollment_type
            if include_concluded:
                params["include[]"] = "concluded"
            
            endpoint = f"/api/v1/courses"
            if user_id:
                endpoint = f"/api/v1/users/{user_id}/courses"
            
            data = await self._make_lms_request("GET", endpoint, params=params)
            
            # Format course data
            courses = []
            for course in data:
                course_summary = {
                    "id": course.get("id"),
                    "name": course.get("name"),
                    "course_code": course.get("course_code"),
                    "workflow_state": course.get("workflow_state"),
                    "start_at": course.get("start_at"),
                    "end_at": course.get("end_at"),
                    "enrollment_term_id": course.get("enrollment_term_id"),
                    "total_students": course.get("total_students", 0)
                }
                courses.append(course_summary)
            
            result = {
                "total_courses": len(courses),
                "courses": courses
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Course retrieval error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to get courses: {str(e)}"
            )]
    
    async def get_course_content(self, course_id: str, include_modules: bool = True,
                               include_assignments: bool = True, include_announcements: bool = False) -> List[types.TextContent]:
        """Get course content including modules, lessons, and materials."""
        try:
            result = {
                "course_id": course_id,
                "modules": [],
                "assignments": [],
                "announcements": []
            }
            
            if include_modules:
                modules_data = await self._make_lms_request("GET", f"/api/v1/courses/{course_id}/modules")
                for module in modules_data:
                    module_summary = {
                        "id": module.get("id"),
                        "name": module.get("name"),
                        "position": module.get("position"),
                        "unlock_at": module.get("unlock_at"),
                        "require_sequential_progress": module.get("require_sequential_progress"),
                        "items_count": module.get("items_count", 0)
                    }
                    result["modules"].append(module_summary)
            
            if include_assignments:
                assignments_data = await self._make_lms_request("GET", f"/api/v1/courses/{course_id}/assignments")
                for assignment in assignments_data:
                    assignment_summary = {
                        "id": assignment.get("id"),
                        "name": assignment.get("name"),
                        "description": assignment.get("description", "")[:200] + "..." if len(assignment.get("description", "")) > 200 else assignment.get("description", ""),
                        "due_at": assignment.get("due_at"),
                        "points_possible": assignment.get("points_possible"),
                        "submission_types": assignment.get("submission_types", []),
                        "workflow_state": assignment.get("workflow_state")
                    }
                    result["assignments"].append(assignment_summary)
            
            if include_announcements:
                announcements_data = await self._make_lms_request("GET", f"/api/v1/courses/{course_id}/discussion_topics", 
                                                                params={"only_announcements": "true"})
                for announcement in announcements_data:
                    announcement_summary = {
                        "id": announcement.get("id"),
                        "title": announcement.get("title"),
                        "message": announcement.get("message", "")[:200] + "..." if len(announcement.get("message", "")) > 200 else announcement.get("message", ""),
                        "posted_at": announcement.get("posted_at"),
                        "author": announcement.get("author", {})
                    }
                    result["announcements"].append(announcement_summary)
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Course content retrieval error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to get course content: {str(e)}"
            )]
    
    async def enroll_student(self, course_id: str, user_id: str, enrollment_type: str = "StudentEnrollment",
                           enrollment_state: str = "active") -> List[types.TextContent]:
        """Enroll a student in a course."""
        try:
            data = {
                "enrollment": {
                    "user_id": user_id,
                    "type": enrollment_type,
                    "enrollment_state": enrollment_state,
                    "notify": True
                }
            }
            
            result = await self._make_lms_request("POST", f"/api/v1/courses/{course_id}/enrollments", json=data)
            
            enrollment_summary = {
                "id": result.get("id"),
                "user_id": result.get("user_id"),
                "course_id": result.get("course_id"),
                "type": result.get("type"),
                "role": result.get("role"),
                "enrollment_state": result.get("enrollment_state"),
                "created_at": result.get("created_at")
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(enrollment_summary, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Student enrollment error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to enroll student: {str(e)}"
            )]
    
    async def submit_assignment(self, course_id: str, assignment_id: str, user_id: str,
                              submission_type: str = "online_text_entry", body: Optional[str] = None,
                              url: Optional[str] = None, file_ids: Optional[List[str]] = None) -> List[types.TextContent]:
        """Submit an assignment for a student."""
        try:
            submission_data = {
                "submission": {
                    "submission_type": submission_type
                }
            }
            
            if body and submission_type == "online_text_entry":
                submission_data["submission"]["body"] = body
            elif url and submission_type == "online_url":
                submission_data["submission"]["url"] = url
            elif file_ids and submission_type == "online_upload":
                submission_data["submission"]["file_ids"] = file_ids
            
            result = await self._make_lms_request("POST", f"/api/v1/courses/{course_id}/assignments/{assignment_id}/submissions", 
                                                json=submission_data)
            
            submission_summary = {
                "id": result.get("id"),
                "user_id": result.get("user_id"),
                "assignment_id": result.get("assignment_id"),
                "submission_type": result.get("submission_type"),
                "workflow_state": result.get("workflow_state"),
                "submitted_at": result.get("submitted_at"),
                "grade": result.get("grade"),
                "score": result.get("score")
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(submission_summary, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Assignment submission error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to submit assignment: {str(e)}"
            )]
    
    async def get_grades(self, course_id: Optional[str] = None, user_id: Optional[str] = None,
                        assignment_id: Optional[str] = None, grading_period_id: Optional[str] = None) -> List[types.TextContent]:
        """Get grades for a student or course."""
        try:
            params = {}
            if grading_period_id:
                params["grading_period_id"] = grading_period_id
            
            if course_id and user_id:
                # Get grades for specific student in specific course
                endpoint = f"/api/v1/courses/{course_id}/students/{user_id}/submissions"
            elif course_id:
                # Get all grades for a course
                endpoint = f"/api/v1/courses/{course_id}/students/submissions"
            elif user_id:
                # Get grades for a user across all courses
                endpoint = f"/api/v1/users/{user_id}/courses"
                params["include[]"] = "total_scores"
            else:
                raise ValueError("Either course_id or user_id must be provided")
            
            data = await self._make_lms_request("GET", endpoint, params=params)
            
            # Format grade data
            grades = []
            if isinstance(data, list):
                for item in data:
                    if "submissions" in str(endpoint):
                        grade_info = {
                            "assignment_id": item.get("assignment_id"),
                            "user_id": item.get("user_id"),
                            "score": item.get("score"),
                            "grade": item.get("grade"),
                            "submitted_at": item.get("submitted_at"),
                            "graded_at": item.get("graded_at"),
                            "workflow_state": item.get("workflow_state")
                        }
                    else:
                        grade_info = {
                            "course_id": item.get("id"),
                            "course_name": item.get("name"),
                            "total_score": item.get("enrollments", [{}])[0].get("computed_current_score") if item.get("enrollments") else None
                        }
                    grades.append(grade_info)
            
            result = {
                "total_grades": len(grades),
                "grades": grades
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Grade retrieval error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to get grades: {str(e)}"
            )]
    
    async def update_grade(self, course_id: str, assignment_id: str, user_id: str, grade: Union[str, float],
                          comment: Optional[str] = None, rubric_assessment: Optional[Dict[str, Any]] = None) -> List[types.TextContent]:
        """Update a grade for an assignment submission."""
        try:
            submission_data = {
                "submission": {
                    "posted_grade": str(grade)
                }
            }
            
            if comment:
                submission_data["comment"] = {
                    "text_comment": comment
                }
            
            if rubric_assessment:
                submission_data["rubric_assessment"] = rubric_assessment
            
            result = await self._make_lms_request("PUT", f"/api/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}", 
                                                json=submission_data)
            
            grade_update_summary = {
                "id": result.get("id"),
                "user_id": result.get("user_id"),
                "assignment_id": result.get("assignment_id"),
                "grade": result.get("grade"),
                "score": result.get("score"),
                "workflow_state": result.get("workflow_state"),
                "graded_at": result.get("graded_at")
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(grade_update_summary, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Grade update error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to update grade: {str(e)}"
            )]
    
    async def create_discussion(self, course_id: str, title: str, message: str,
                              discussion_type: str = "threaded", published: bool = True,
                              allow_rating: bool = False) -> List[types.TextContent]:
        """Create a discussion topic in a course."""
        try:
            data = {
                "title": title,
                "message": message,
                "discussion_type": discussion_type,
                "published": published,
                "allow_rating": allow_rating
            }
            
            result = await self._make_lms_request("POST", f"/api/v1/courses/{course_id}/discussion_topics", json=data)
            
            discussion_summary = {
                "id": result.get("id"),
                "title": result.get("title"),
                "author": result.get("author"),
                "created_at": result.get("created_at"),
                "discussion_type": result.get("discussion_type"),
                "published": result.get("published"),
                "html_url": result.get("html_url")
            }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(discussion_summary, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Discussion creation error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to create discussion: {str(e)}"
            )]
    
    async def get_analytics(self, course_id: Optional[str] = None, user_id: Optional[str] = None,
                          metric: Optional[str] = None, start_date: Optional[str] = None,
                          end_date: Optional[str] = None) -> List[types.TextContent]:
        """Get learning analytics data for courses and students."""
        try:
            # This is a simplified analytics implementation
            # Real LMS systems would have more sophisticated analytics APIs
            
            params = {}
            if start_date:
                params["start_time"] = start_date
            if end_date:
                params["end_time"] = end_date
            
            analytics_data = {}
            
            if course_id and metric == "participation":
                # Get course participation data
                endpoint = f"/api/v1/courses/{course_id}/analytics/activity"
                data = await self._make_lms_request("GET", endpoint, params=params)
                analytics_data["participation"] = data
                
            elif course_id and metric == "page_views":
                # Get page view analytics
                endpoint = f"/api/v1/courses/{course_id}/analytics/activity"
                data = await self._make_lms_request("GET", endpoint, params=params)
                analytics_data["page_views"] = data
                
            else:
                # General analytics summary
                analytics_data = {
                    "course_id": course_id,
                    "user_id": user_id,
                    "metric": metric,
                    "period": f"{start_date} to {end_date}" if start_date and end_date else "all time",
                    "summary": {
                        "total_activity": 0,
                        "engagement_score": 0,
                        "completion_rate": 0
                    }
                }
            
            return [types.TextContent(
                type="text",
                text=json.dumps(analytics_data, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Analytics retrieval error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to get analytics: {str(e)}"
            )]
    
    async def sync_gradebook(self, source_course_id: str, target_course_id: str,
                           sync_type: str = "grades_only", overwrite_existing: bool = False) -> List[types.TextContent]:
        """Synchronize gradebook data between systems."""
        try:
            # This is a simplified sync implementation
            sync_summary = {
                "source_course_id": source_course_id,
                "target_course_id": target_course_id,
                "sync_type": sync_type,
                "overwrite_existing": overwrite_existing,
                "sync_timestamp": datetime.utcnow().isoformat(),
                "status": "in_progress",
                "synced_items": {
                    "assignments": 0,
                    "grades": 0,
                    "students": 0
                }
            }
            
            # Get source course data
            source_assignments = await self._make_lms_request("GET", f"/api/v1/courses/{source_course_id}/assignments")
            source_submissions = await self._make_lms_request("GET", f"/api/v1/courses/{source_course_id}/students/submissions")
            
            sync_summary["synced_items"]["assignments"] = len(source_assignments)
            sync_summary["synced_items"]["grades"] = len(source_submissions)
            sync_summary["status"] = "completed"
            
            return [types.TextContent(
                type="text",
                text=json.dumps(sync_summary, indent=2)
            )]
            
        except Exception as e:
            logger.error(f"Gradebook sync error: {str(e)}")
            return [types.TextContent(
                type="text",
                text=f"Failed to sync gradebook: {str(e)}"
            )]
    
    async def get_course_templates(self) -> str:
        """Get standard course templates and structures."""
        templates = {
            "basic_course": {
                "name": "Basic Course Template",
                "modules": [
                    {"name": "Introduction", "items": ["Welcome", "Syllabus", "Course Overview"]},
                    {"name": "Week 1", "items": ["Readings", "Lecture Videos", "Discussion", "Assignment"]},
                    {"name": "Week 2", "items": ["Readings", "Lecture Videos", "Discussion", "Quiz"]},
                    {"name": "Final Assessment", "items": ["Final Project", "Reflection"]}
                ],
                "grading_scheme": {
                    "assignments": 40,
                    "discussions": 20,
                    "quizzes": 20,
                    "final_project": 20
                }
            },
            "blended_learning": {
                "name": "Blended Learning Template",
                "modules": [
                    {"name": "Online Orientation", "items": ["Platform Tutorial", "Expectations"]},
                    {"name": "Unit 1", "items": ["Online Content", "In-Person Session", "Collaborative Project"]},
                    {"name": "Unit 2", "items": ["Virtual Lab", "Peer Review", "Reflection"]},
                    {"name": "Capstone", "items": ["Final Presentation", "Portfolio"]}
                ]
            },
            "project_based": {
                "name": "Project-Based Learning Template",
                "modules": [
                    {"name": "Project Planning", "items": ["Problem Definition", "Research Phase"]},
                    {"name": "Development", "items": ["Prototype", "Testing", "Iteration"]},
                    {"name": "Implementation", "items": ["Final Product", "Documentation"]},
                    {"name": "Presentation", "items": ["Demo", "Peer Evaluation"]}
                ]
            }
        }
        
        return json.dumps(templates, indent=2)
    
    async def get_assignment_rubrics(self) -> str:
        """Get common assignment rubric templates."""
        rubrics = {
            "essay_rubric": {
                "criteria": {
                    "content": {
                        "excellent": "Demonstrates comprehensive understanding",
                        "good": "Shows good understanding with minor gaps",
                        "satisfactory": "Basic understanding evident",
                        "needs_improvement": "Limited understanding shown"
                    },
                    "organization": {
                        "excellent": "Clear, logical structure throughout",
                        "good": "Generally well-organized",
                        "satisfactory": "Basic organization present",
                        "needs_improvement": "Lacks clear organization"
                    },
                    "writing_quality": {
                        "excellent": "Exceptional clarity and style",
                        "good": "Clear and engaging writing",
                        "satisfactory": "Adequate writing quality",
                        "needs_improvement": "Writing needs improvement"
                    }
                },
                "points": {"excellent": 4, "good": 3, "satisfactory": 2, "needs_improvement": 1}
            },
            "presentation_rubric": {
                "criteria": {
                    "content_knowledge": "Demonstrates understanding of topic",
                    "delivery": "Clear speech, appropriate pace",
                    "visual_aids": "Effective use of slides/materials",
                    "engagement": "Maintains audience interest"
                }
            },
            "project_rubric": {
                "criteria": {
                    "planning": "Evidence of thorough planning",
                    "execution": "Quality of final product",
                    "innovation": "Creative or original approach",
                    "documentation": "Clear documentation and reflection"
                }
            }
        }
        
        return json.dumps(rubrics, indent=2)
    
    async def get_grade_scales(self) -> str:
        """Get standard grading scales and conversion tables."""
        scales = {
            "standard_letter": {
                "A": {"min": 90, "max": 100},
                "B": {"min": 80, "max": 89},
                "C": {"min": 70, "max": 79},
                "D": {"min": 60, "max": 69},
                "F": {"min": 0, "max": 59}
            },
            "plus_minus": {
                "A+": {"min": 97, "max": 100},
                "A": {"min": 93, "max": 96},
                "A-": {"min": 90, "max": 92},
                "B+": {"min": 87, "max": 89},
                "B": {"min": 83, "max": 86},
                "B-": {"min": 80, "max": 82}
            },
            "pass_fail": {
                "Pass": {"min": 70, "max": 100},
                "Fail": {"min": 0, "max": 69}
            },
            "ib_scale": {
                "7": {"min": 85, "max": 100, "description": "Excellent"},
                "6": {"min": 75, "max": 84, "description": "Very Good"},
                "5": {"min": 65, "max": 74, "description": "Good"},
                "4": {"min": 55, "max": 64, "description": "Satisfactory"}
            }
        }
        
        return json.dumps(scales, indent=2)
    
    async def get_analytics_reports(self) -> str:
        """Get learning analytics report templates."""
        reports = {
            "student_progress": {
                "title": "Student Progress Report",
                "metrics": ["assignment_completion", "grade_trends", "participation", "time_on_task"],
                "visualizations": ["progress_bar", "line_chart", "heat_map"],
                "frequency": "weekly"
            },
            "course_engagement": {
                "title": "Course Engagement Analysis",
                "metrics": ["page_views", "discussion_posts", "resource_access", "submission_timeliness"],
                "visualizations": ["dashboard", "bar_chart", "activity_timeline"],
                "frequency": "monthly"
            },
            "learning_outcomes": {
                "title": "Learning Outcomes Assessment",
                "metrics": ["mastery_levels", "skill_development", "competency_tracking"],
                "visualizations": ["radar_chart", "progress_matrix"],
                "frequency": "semester"
            }
        }
        
        return json.dumps(reports, indent=2)
    
    async def get_assignment_feedback_prompt(self, arguments: Dict[str, str]) -> types.GetPromptResult:
        """Generate personalized assignment feedback prompt."""
        assignment_title = arguments.get('assignment_title', '')
        student_submission = arguments.get('student_submission', '')
        rubric_criteria = arguments.get('rubric_criteria', 'No rubric provided')
        tone = arguments.get('tone', 'encouraging')
        
        if not assignment_title or not student_submission:
            raise ValueError("Assignment title and student submission are required")
        
        prompt_text = f"""Please provide {tone} feedback for the following assignment:

**Assignment**: {assignment_title}

**Student Submission**:
{student_submission}

**Rubric Criteria**:
{rubric_criteria}

Please provide feedback that:
1. Highlights the student's strengths and what they did well
2. Identifies specific areas for improvement with concrete suggestions
3. Connects feedback to the learning objectives
4. Maintains a {tone} and supportive tone
5. Includes actionable next steps for the student

Format your feedback in a clear, organized manner suitable for student learning."""
        
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(
                    type="text",
                    text=prompt_text
                )
            )
        ]
        
        return types.GetPromptResult(messages=messages)
    
    async def get_course_announcement_prompt(self, arguments: Dict[str, str]) -> types.GetPromptResult:
        """Generate course announcement prompt."""
        announcement_type = arguments.get('announcement_type', '')
        course_name = arguments.get('course_name', '')
        key_points = arguments.get('key_points', '')
        urgency = arguments.get('urgency', 'medium')
        
        if not announcement_type or not course_name or not key_points:
            raise ValueError("Announcement type, course name, and key points are required")
        
        urgency_indicators = {
            'high': '🚨 URGENT',
            'medium': '📢',
            'low': '💡'
        }
        
        prompt_text = f"""Create a {announcement_type} announcement for {course_name} with {urgency} urgency.

**Key Information to Include**:
{key_points}

**Requirements**:
- Use appropriate tone for {announcement_type} announcement
- Include clear subject line with {urgency_indicators.get(urgency, '📢')} indicator
- Organize information clearly with bullets or sections
- Include relevant dates, deadlines, or action items
- End with appropriate contact information or next steps
- Keep language clear and accessible to students

**Urgency Level**: {urgency} - adjust tone and formatting accordingly."""
        
        messages = [
            types.PromptMessage(
                role="user",
                content=types.TextContent(
                    type="text",
                    text=prompt_text
                )
            )
        ]
        
        return types.GetPromptResult(messages=messages)
    
    async def _make_lms_request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None,
                              json: Optional[Dict[str, Any]] = None) -> Any:
        """Make authenticated request to LMS API."""
        if not self.api_token:
            raise ValueError("API token required for LMS requests")
        
        url = urljoin(self.lms_base_url, endpoint)
        
        headers = {
            "Authorization": f"Bearer {self.api_token}",
            "Content-Type": "application/json"
        }
        
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            response = await client.request(method, url, headers=headers, params=params, json=json)
            response.raise_for_status()
            return response.json()
    
    def validate_config(self) -> bool:
        """Validate server configuration."""
        required_keys = ["lms_base_url", "api_token"]
        missing_keys = [key for key in required_keys if key not in self.config]
        
        if missing_keys:
            logger.error(f"Missing required configuration keys: {missing_keys}")
            return False
        
        return True
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check and return status."""
        try:
            # Test LMS API connectivity
            if self.api_token:
                await self._make_lms_request("GET", "/api/v1/courses", params={"per_page": 1})
                lms_accessible = True
            else:
                lms_accessible = False
        except:
            lms_accessible = False
        
        return {
            "status": "healthy" if lms_accessible else "degraded",
            "lms_accessible": lms_accessible,
            "lms_type": self.lms_type,
            "timestamp": datetime.utcnow().isoformat(),
            "version": "1.0.0",
            "config_valid": self.validate_config()
        }
    
    async def run(self):
        """Run the Education LMS MCP server."""
        if not self.validate_config():
            logger.error("Invalid configuration, server cannot start")
            return
        
        logger.info("Starting Education LMS MCP server...")
        
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream, 
                write_stream, 
                InitializeResult(
                    protocolVersion="2024-11-05",
                    capabilities=types.ServerCapabilities(
                        tools={},
                        resources={},
                        prompts={},
                        logging={}
                    ),
                    serverInfo=types.Implementation(
                        name="education-lms-server",
                        version="1.0.0"
                    )
                )
            )

async def main():
    """Main entry point for the Education LMS server."""
    import argparse
    import sys
    
    parser = argparse.ArgumentParser(description="Education LMS MCP Server")
    parser.add_argument("--config", type=str, help="Path to configuration file")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("--lms-url", type=str, help="LMS base URL")
    parser.add_argument("--api-token", type=str, help="API authentication token")
    parser.add_argument("--lms-type", type=str, choices=["canvas", "blackboard", "moodle"], help="LMS platform type")
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    config = {}
    if args.config:
        try:
            with open(args.config, 'r') as f:
                config = json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config file: {e}")
            sys.exit(1)
    
    # Override config with command line arguments
    if args.lms_url:
        config['lms_base_url'] = args.lms_url
    if args.api_token:
        config['api_token'] = args.api_token
    if args.lms_type:
        config['lms_type'] = args.lms_type
    
    server = EducationLmsServer(config)
    
    try:
        await server.run()
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
    except Exception as e:
        logger.error(f"Server error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())