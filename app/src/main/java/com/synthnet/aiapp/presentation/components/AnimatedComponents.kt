package com.synthnet.aiapp.presentation.components

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.*
import androidx.compose.ui.draw.*
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.*
import com.synthnet.aiapp.domain.models.*
import com.synthnet.aiapp.presentation.theme.*
import kotlinx.coroutines.delay

@Composable
fun ThinkingIndicator(\n    isThinking: Boolean,\n    modifier: Modifier = Modifier,\n    color: Color = MaterialTheme.colorScheme.primary\n) {\n    AnimatedVisibility(\n        visible = isThinking,\n        enter = fadeIn() + scaleIn(),\n        exit = fadeOut() + scaleOut(),\n        modifier = modifier\n    ) {\n        Row(\n            horizontalArrangement = Arrangement.spacedBy(4.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            repeat(3) { index ->\n                val infiniteTransition = rememberInfiniteTransition()\n                val alpha by infiniteTransition.animateFloat(\n                    initialValue = 0.3f,\n                    targetValue = 1f,\n                    animationSpec = infiniteRepeatable(\n                        animation = tween(\n                            durationMillis = 600,\n                            delayMillis = index * 200,\n                            easing = LinearEasing\n                        ),\n                        repeatMode = RepeatMode.Reverse\n                    )\n                )\n                \n                Box(\n                    modifier = Modifier\n                        .size(8.dp)\n                        .background(\n                            color.copy(alpha = alpha),\n                            CircleShape\n                        )\n                )\n            }\n            \n            Spacer(modifier = Modifier.width(8.dp))\n            \n            Text(\n                text = "Thinking...",\n                style = MaterialTheme.typography.bodySmall,\n                color = color.copy(alpha = 0.7f)\n            )\n        }\n    }\n}\n\n@Composable\nfun PulsingIcon(\n    icon: ImageVector,\n    isActive: Boolean,\n    modifier: Modifier = Modifier,\n    activeColor: Color = AIGreen,\n    inactiveColor: Color = AIGrey\n) {\n    val infiniteTransition = rememberInfiniteTransition()\n    \n    val scale by infiniteTransition.animateFloat(\n        initialValue = if (isActive) 1f else 1f,\n        targetValue = if (isActive) 1.2f else 1f,\n        animationSpec = if (isActive) {\n            infiniteRepeatable(\n                animation = tween(1000, easing = FastOutSlowInEasing),\n                repeatMode = RepeatMode.Reverse\n            )\n        } else {\n            infiniteRepeatable(\n                animation = tween(0),\n                repeatMode = RepeatMode.Restart\n            )\n        }\n    )\n    \n    val color by animateColorAsState(\n        targetValue = if (isActive) activeColor else inactiveColor,\n        animationSpec = tween(500)\n    )\n    \n    Icon(\n        imageVector = icon,\n        contentDescription = null,\n        tint = color,\n        modifier = modifier\n            .scale(scale)\n            .size(24.dp)\n    )\n}\n\n@Composable\nfun AnimatedProgressBar(\n    progress: Float,\n    modifier: Modifier = Modifier,\n    backgroundColor: Color = MaterialTheme.colorScheme.surfaceVariant,\n    progressColor: Color = MaterialTheme.colorScheme.primary,\n    animationDuration: Int = 1000\n) {\n    var animatedProgress by remember { mutableStateOf(0f) }\n    \n    LaunchedEffect(progress) {\n        animatedProgress = progress\n    }\n    \n    val animatedProgressValue by animateFloatAsState(\n        targetValue = animatedProgress,\n        animationSpec = tween(durationMillis = animationDuration, easing = EaseOutCubic)\n    )\n    \n    Box(\n        modifier = modifier\n            .fillMaxWidth()\n            .height(8.dp)\n            .background(backgroundColor, RoundedCornerShape(4.dp))\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxHeight()\n                .fillMaxWidth(animatedProgressValue)\n                .background(\n                    brush = Brush.horizontalGradient(\n                        colors = listOf(\n                            progressColor.copy(alpha = 0.8f),\n                            progressColor\n                        )\n                    ),\n                    shape = RoundedCornerShape(4.dp)\n                )\n        )\n    }\n}\n\n@Composable\nfun AnimatedMetricCard(\n    title: String,\n    value: String,\n    trend: Float, // Positive for up, negative for down\n    icon: ImageVector,\n    modifier: Modifier = Modifier\n) {\n    var isVisible by remember { mutableStateOf(false) }\n    \n    LaunchedEffect(Unit) {\n        delay(100)\n        isVisible = true\n    }\n    \n    AnimatedVisibility(\n        visible = isVisible,\n        enter = slideInVertically(initialOffsetY = { it }) + fadeIn(),\n        modifier = modifier\n    ) {\n        Card(\n            modifier = Modifier.fillMaxWidth(),\n            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),\n            colors = CardDefaults.cardColors(\n                containerColor = MaterialTheme.colorScheme.surface\n            )\n        ) {\n            Column(\n                modifier = Modifier.padding(16.dp)\n            ) {\n                Row(\n                    modifier = Modifier.fillMaxWidth(),\n                    horizontalArrangement = Arrangement.SpaceBetween,\n                    verticalAlignment = Alignment.CenterVertically\n                ) {\n                    Icon(\n                        imageVector = icon,\n                        contentDescription = null,\n                        tint = MaterialTheme.colorScheme.primary,\n                        modifier = Modifier.size(24.dp)\n                    )\n                    \n                    TrendIndicator(trend = trend)\n                }\n                \n                Spacer(modifier = Modifier.height(8.dp))\n                \n                Text(\n                    text = value,\n                    style = MaterialTheme.typography.headlineMedium,\n                    fontWeight = FontWeight.Bold\n                )\n                \n                Text(\n                    text = title,\n                    style = MaterialTheme.typography.bodyMedium,\n                    color = MaterialTheme.colorScheme.onSurfaceVariant\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun TrendIndicator(\n    trend: Float,\n    modifier: Modifier = Modifier\n) {\n    val isPositive = trend > 0\n    val color = if (isPositive) AIGreen else AIRed\n    val icon = if (isPositive) Icons.Default.TrendingUp else Icons.Default.TrendingDown\n    \n    val infiniteTransition = rememberInfiniteTransition()\n    val animatedAlpha by infiniteTransition.animateFloat(\n        initialValue = 0.7f,\n        targetValue = 1f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(1500),\n            repeatMode = RepeatMode.Reverse\n        )\n    )\n    \n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = modifier\n    ) {\n        Icon(\n            imageVector = icon,\n            contentDescription = null,\n            tint = color.copy(alpha = animatedAlpha),\n            modifier = Modifier.size(16.dp)\n        )\n        \n        Text(\n            text = "${if (isPositive) "+" else ""}${(trend * 100).toInt()}%",\n            style = MaterialTheme.typography.labelSmall,\n            color = color.copy(alpha = animatedAlpha),\n            fontWeight = FontWeight.Medium\n        )\n    }\n}\n\n@Composable\nfun FloatingActionMenu(\n    isExpanded: Boolean,\n    onToggle: () -> Unit,\n    actions: List<FloatingAction>,\n    modifier: Modifier = Modifier\n) {\n    val density = LocalDensity.current\n    \n    Column(\n        modifier = modifier,\n        horizontalAlignment = Alignment.End\n    ) {\n        actions.forEachIndexed { index, action ->\n            AnimatedVisibility(\n                visible = isExpanded,\n                enter = slideInVertically(\n                    initialOffsetY = { with(density) { 50.dp.roundToPx() } },\n                    animationSpec = tween(\n                        durationMillis = 300,\n                        delayMillis = index * 50\n                    )\n                ) + fadeIn(animationSpec = tween(300, delayMillis = index * 50)),\n                exit = slideOutVertically(\n                    targetOffsetY = { with(density) { 50.dp.roundToPx() } }\n                ) + fadeOut()\n            ) {\n                Row(\n                    verticalAlignment = Alignment.CenterVertically,\n                    modifier = Modifier.padding(vertical = 4.dp)\n                ) {\n                    Surface(\n                        color = MaterialTheme.colorScheme.surface,\n                        shadowElevation = 2.dp,\n                        shape = RoundedCornerShape(8.dp)\n                    ) {\n                        Text(\n                            text = action.label,\n                            modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),\n                            style = MaterialTheme.typography.bodySmall\n                        )\n                    }\n                    \n                    Spacer(modifier = Modifier.width(8.dp))\n                    \n                    SmallFloatingActionButton(\n                        onClick = action.onClick,\n                        containerColor = action.backgroundColor,\n                        contentColor = action.contentColor\n                    ) {\n                        Icon(\n                            imageVector = action.icon,\n                            contentDescription = action.label\n                        )\n                    }\n                }\n            }\n        }\n        \n        Spacer(modifier = Modifier.height(8.dp))\n        \n        FloatingActionButton(\n            onClick = onToggle,\n            modifier = Modifier.scale(if (isExpanded) 1.1f else 1f)\n        ) {\n            Icon(\n                imageVector = if (isExpanded) Icons.Default.Close else Icons.Default.Add,\n                contentDescription = if (isExpanded) "Close menu" else "Open menu"\n            )\n        }\n    }\n}\n\ndata class FloatingAction(\n    val icon: ImageVector,\n    val label: String,\n    val onClick: () -> Unit,\n    val backgroundColor: Color = Color.Unspecified,\n    val contentColor: Color = Color.Unspecified\n)\n\n@Composable\nfun WaveformVisualizer(\n    isActive: Boolean,\n    modifier: Modifier = Modifier,\n    color: Color = MaterialTheme.colorScheme.primary\n) {\n    val infiniteTransition = rememberInfiniteTransition()\n    \n    Row(\n        modifier = modifier,\n        horizontalArrangement = Arrangement.spacedBy(2.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        repeat(12) { index ->\n            val animatedHeight by infiniteTransition.animateFloat(\n                initialValue = 4f,\n                targetValue = if (isActive) (16f + kotlin.random.Random.nextFloat() * 20f) else 4f,\n                animationSpec = infiniteRepeatable(\n                    animation = tween(\n                        durationMillis = 600 + (index * 100),\n                        easing = EaseInOutSine\n                    ),\n                    repeatMode = RepeatMode.Reverse\n                )\n            )\n            \n            Box(\n                modifier = Modifier\n                    .width(3.dp)\n                    .height(animatedHeight.dp)\n                    .background(\n                        color.copy(alpha = if (isActive) 1f else 0.3f),\n                        RoundedCornerShape(1.5.dp)\n                    )\n            )\n        }\n    }\n}\n\n@Composable\nfun RotatingIcon(\n    icon: ImageVector,\n    isRotating: Boolean,\n    modifier: Modifier = Modifier,\n    tint: Color = MaterialTheme.colorScheme.primary\n) {\n    val infiniteTransition = rememberInfiniteTransition()\n    \n    val rotation by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = if (isRotating) 360f else 0f,\n        animationSpec = if (isRotating) {\n            infiniteRepeatable(\n                animation = tween(2000, easing = LinearEasing),\n                repeatMode = RepeatMode.Restart\n            )\n        } else {\n            infiniteRepeatable(\n                animation = tween(0),\n                repeatMode = RepeatMode.Restart\n            )\n        }\n    )\n    \n    Icon(\n        imageVector = icon,\n        contentDescription = null,\n        tint = tint,\n        modifier = modifier.rotate(rotation)\n    )\n}\n\n@Composable\nfun GlowingBorder(\n    isGlowing: Boolean,\n    modifier: Modifier = Modifier,\n    glowColor: Color = MaterialTheme.colorScheme.primary,\n    content: @Composable () -> Unit\n) {\n    val infiniteTransition = rememberInfiniteTransition()\n    \n    val glowAlpha by infiniteTransition.animateFloat(\n        initialValue = if (isGlowing) 0.3f else 0f,\n        targetValue = if (isGlowing) 0.8f else 0f,\n        animationSpec = if (isGlowing) {\n            infiniteRepeatable(\n                animation = tween(1500, easing = EaseInOutSine),\n                repeatMode = RepeatMode.Reverse\n            )\n        } else {\n            tween(300)\n        }\n    )\n    \n    Box(\n        modifier = modifier\n            .border(\n                width = 2.dp,\n                color = glowColor.copy(alpha = glowAlpha),\n                shape = RoundedCornerShape(12.dp)\n            )\n            .padding(2.dp)\n    ) {\n        content()\n    }\n}\n\n@Composable\nfun CollaborationPresenceIndicator(\n    participants: List<AgentPresence>,\n    modifier: Modifier = Modifier\n) {\n    LazyRow(\n        modifier = modifier,\n        horizontalArrangement = Arrangement.spacedBy((-8).dp)\n    ) {\n        items(participants.take(5)) { presence ->\n            val isActive = presence.isActive\n            val color = if (isActive) AIGreen else AIGrey\n            \n            Box(\n                modifier = Modifier\n                    .size(32.dp)\n                    .background(\n                        color,\n                        CircleShape\n                    )\n                    .border(\n                        2.dp,\n                        MaterialTheme.colorScheme.surface,\n                        CircleShape\n                    )\n            ) {\n                if (isActive) {\n                    val infiniteTransition = rememberInfiniteTransition()\n                    val pulseAlpha by infiniteTransition.animateFloat(\n                        initialValue = 0.3f,\n                        targetValue = 0.8f,\n                        animationSpec = infiniteRepeatable(\n                            animation = tween(1000),\n                            repeatMode = RepeatMode.Reverse\n                        )\n                    )\n                    \n                    Box(\n                        modifier = Modifier\n                            .fillMaxSize()\n                            .background(\n                                Color.White.copy(alpha = pulseAlpha),\n                                CircleShape\n                            )\n                    )\n                }\n                \n                // Agent initial or icon\n                Box(\n                    modifier = Modifier.fillMaxSize(),\n                    contentAlignment = Alignment.Center\n                ) {\n                    Text(\n                        text = presence.agentId.take(1).uppercase(),\n                        style = MaterialTheme.typography.labelSmall,\n                        color = Color.White,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            }\n        }\n        \n        if (participants.size > 5) {\n            item {\n                Box(\n                    modifier = Modifier\n                        .size(32.dp)\n                        .background(\n                            MaterialTheme.colorScheme.outline,\n                            CircleShape\n                        ),\n                    contentAlignment = Alignment.Center\n                ) {\n                    Text(\n                        text = "+${participants.size - 5}",\n                        style = MaterialTheme.typography.labelSmall,\n                        color = MaterialTheme.colorScheme.onSurface,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            }\n        }\n    }\n}"